generator client {
  provider = "prisma-client"
  output   = "./src/generated"
}

datasource db {
  provider = "sqlite"
}

// Lifecycle status for account credentials stored in `Account`.
enum AccountStatus {
  active
  disabled
}

// Stores one OAuth credential set per (email, appId) pair.
// appId is the Google OAuth client ID used during login, enabling
// multiple OAuth apps per email (different quotas, scopes, etc.).
// Default is the Thunderbird client ID (the original/only client).
model Account {
  email         String
  appId         String
  accountStatus AccountStatus
  tokens        String // JSON-encoded OAuth2 Credentials
  createdAt     DateTime
  updatedAt     DateTime @updatedAt

  threadLists    ThreadList[]
  threads        Thread[]
  labels         Label?
  labelCounts    LabelCount?
  profiles       Profile?
  syncStates     SyncState[]
  calendarLists  CalendarList?
  calendarEvents CalendarEvent[]

  @@id([email, appId])
}

// Caches thread list/search responses per account and query parameters.
// Used for fast list/search rendering and reduced Gmail API calls.
// rawData stores the raw Google gmail_v1.Schema$Thread[] metadata responses
// so the cache is resilient to changes in our own ThreadListResult type.
model ThreadList {
  id         Int      @id @default(autoincrement())
  email      String
  appId      String
  folder     String
  query      String
  labelIds   String
  pageToken  String
  maxResults Int
  rawData    String // raw Google API response JSON (gmail_v1.Schema$Thread[])
  ttlMs      Int
  createdAt  DateTime

  account Account @relation(fields: [email, appId], references: [email, appId], onDelete: Cascade)

  @@unique([email, appId, folder, query, labelIds, pageToken, maxResults])
}

// Caches hydrated thread payloads per account + thread ID.
// Used by mail read and post-mutation cache invalidation.
// rawData stores the raw Google gmail_v1.Schema$Thread response (format: full)
// so the cache is resilient to changes in our own ThreadData type.
// Indexed columns are extracted for queryability and display.
model Thread {
  id        Int      @id @default(autoincrement())
  email     String
  appId     String
  threadId  String
  subject   String   // extracted for display/search
  snippet   String   // extracted for display
  fromEmail String   // extracted for filtering
  fromName  String   // extracted for display
  date      String   // extracted for sorting (RFC2822 from header)
  labelIds  String   // comma-separated, extracted for filtering
  hasUnread Boolean  // extracted for filtering
  msgCount  Int      // extracted for display
  historyId String?  // for sync
  rawData   String   // raw Google API response JSON (gmail_v1.Schema$Thread)
  ttlMs     Int
  createdAt DateTime

  account Account @relation(fields: [email, appId], references: [email, appId], onDelete: Cascade)

  @@unique([email, appId, threadId])
}

// Caches label metadata per account (label id/name/type payload).
// Used by label list/get and related command outputs.
// rawData stores the raw Google gmail_v1.Schema$Label[] response.
model Label {
  email     String
  appId     String
  rawData   String // raw Google API response JSON (gmail_v1.Schema$Label[])
  ttlMs     Int
  createdAt DateTime

  account Account @relation(fields: [email, appId], references: [email, appId], onDelete: Cascade)

  @@id([email, appId])
}

// Caches unread counts per label per account.
// Used by label counts to avoid recomputing on every invocation.
// rawData stores the raw Google gmail_v1.Schema$Label[] detail responses
// (including messagesTotal/threadsUnread counts).
model LabelCount {
  email     String
  appId     String
  rawData   String // raw Google API response JSON (gmail_v1.Schema$Label[] with counts)
  ttlMs     Int
  createdAt DateTime

  account Account @relation(fields: [email, appId], references: [email, appId], onDelete: Cascade)

  @@id([email, appId])
}

// Caches Gmail profile payload per account (totals/history id).
// Used by profile command and account metadata lookups.
// Fully flattened — no JSON blob needed, only 4 fields from Google.
model Profile {
  email         String
  appId         String
  emailAddress  String   // from Gmail API
  messagesTotal Int      // from Gmail API
  threadsTotal  Int      // from Gmail API
  historyId     String   // from Gmail API
  ttlMs         Int
  createdAt     DateTime

  account Account @relation(fields: [email, appId], references: [email, appId], onDelete: Cascade)

  @@id([email, appId])
}

// Caches calendar list per account.
// Used by cal list to avoid fetching calendar metadata on every invocation.
// rawData stores parsed CalendarListItem[] JSON (not raw tsdav — parsed at write time).
model CalendarList {
  email     String
  appId     String
  rawData   String // JSON blob of CalendarListItem[]
  ttlMs     Int
  createdAt DateTime

  account Account @relation(fields: [email, appId], references: [email, appId], onDelete: Cascade)

  @@id([email, appId])
}

// Caches calendar event list responses per account and query parameters.
// Used for fast cal events rendering and reduced Calendar API calls.
// rawData stores parsed EventListResult JSON (not raw tsdav — parsed at write time).
model CalendarEvent {
  id         Int      @id @default(autoincrement())
  email      String
  appId      String
  calendarId String
  timeMin    String
  timeMax    String
  query      String
  maxResults Int
  pageToken  String
  rawData    String // JSON blob of EventListResult
  ttlMs      Int
  createdAt  DateTime

  account Account @relation(fields: [email, appId], references: [email, appId], onDelete: Cascade)

  @@unique([email, appId, calendarId, timeMin, timeMax, query, maxResults, pageToken])
}

// Stores persistent per-account sync metadata as generic key/value pairs.
// Use this for lightweight sync cursors and markers that are not cached API
// payloads, for example `history_id` (incremental Gmail history cursor),
// `last_full_sync_at`, or other small account-scoped checkpoints.
model SyncState {
  email String
  appId String
  key   String
  value String

  account Account @relation(fields: [email, appId], references: [email, appId], onDelete: Cascade)

  @@id([email, appId, key])
}
